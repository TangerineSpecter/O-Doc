export const articleDemoData = {
  article_id: "note_001",
  title: "深度算法分析：从 DFS 到图论的演进",
  category: "算法与数据结构",
  date: "2025/11/14",
  tags: [
    "算法基础",
    "图论",
    "回溯搜索",
    "Python"
  ],
  content: [
    "> \"细节不是细节，它们构成了设计。\" —— Charles Eames",
    "",
    "本笔记整理了 **DFS** 的核心概念与代码模板，包含数学公式推导与复杂度分析。",
    "测试高亮功能：++红色下划线重点++，还有^^天蓝色波浪线^^，以及==重点水彩标记==。",
    "",
    "## 1. 列表演示",
    "",
    "### 1.1 无序列表",
    "- **核心算法**：DFS, BFS, Dijkstra",
    "- **数据结构**：",
    "  - 数组 (Array)",
    "  - 链表 (Linked List)",
    "    - 单向链表",
    "    - 双向链表",
    "  - 栈与队列",
    "",
    "### 1.2 有序列表",
    "1. 初始化 visited 数组",
    "2. 选择起始节点",
    "3. 递归访问：",
    "   1. 标记当前节点",
    "   2. 遍历邻居节点",
    "   3. 回溯（如果需要）",
    "",
    "### 1.3 任务清单 (Task Lists)",
    "- [x] 复习递归基础",
    "- [x] 理解栈的原理",
    "- [ ] 刷 LeetCode 200 题 (岛屿数量)",
    "- [ ] 整理 Tarjan 算法笔记",
    "",
    "---",
    "",
    "## 2. 链接与引用",
    "",
    "在学习过程中，推荐使用 [VisuAlgo](https://visualgo.net/) 进行可视化学习。它对理解 **Graph** 结构非常有帮助。",
    "",
    "> 💡 **Tip**: 记得不仅要看代码，还要自己手画递归树。",
    "",
    "## 3. 图片展示效果",
    "",
    "这里展示一张关于算法数据结构的概念图：",
    "",
    "![算法概念图](https://img.shetu66.com/2022/11/03/1667459511305837.jpg)",
    "*图1: 现代数据中心与算法可视化*",
    "",
    "---",
    "",
    "## 4. 核心概念",
    "",
    "深度优先搜索（DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。",
    "",
    "### 4.1 关键特性",
    "1.  **递归实现**：代码简洁，利用系统栈。",
    "2.  **栈实现**：迭代版本，防止栈溢出。",
    "3.  **应用场景**：路径查找、拓扑排序、连通性检测。",
    "",
    "---",
    "",
    "## 5. 知识点标签",
    "",
    "#算法 #DFS #图论 #笔记",
    "",
    "## 6. 代码模板",
    "",
    "以下是通用的 Python 递归模板，注意 `visited` 数组的使用。",
    "",
    "```python",
    "def dfs(graph, start, visited=None):",
    "    if visited is None:",
    "        visited = set()",
    "    ",
    "    # 标记当前节点",
    "    visited.add(start)",
    "    print(f\"Visiting {start}\")",
    "    ",
    "    # 递归访问邻居",
    "    for next_node in graph[start] - visited:",
    "        dfs(graph, next_node, visited)",
    "    ",
    "    return visited",
    "",
    "# 图的表示",
    "graph = {'0': set(['1', '2']),",
    "         '1': set(['0', '3', '4']),",
    "         '2': set(['0']),",
    "         '3': set(['1']),",
    "         '4': set(['2', '3'])} ",
    "",
    "dfs(graph, '0')",
    "```",
    "",
    "命令行执行测试：",
    "```bash",
    "python dfs_test.py --verbose",
    "```",
    "",
    "## 7. 数学推导",
    "",
    "时间复杂度取决于节点数 $V$ 和边数 $E$。",
    "在邻接表表示中，复杂度为：",
    "",
    "$$T(V, E) = \\Theta(V + E)$$",
    "",
    "如果使用邻接矩阵，复杂度则上升为：",
    "",
    "$$T(V, E) = \\Theta(V^2)$$",
    "",
    "## 8. 流程可视化",
    "",
    "算法执行过程如下：",
    "",
    "```mermaid",
    "graph TD",
    "    A[\"Start Node\"] --> B{\"Visited?\"}",
    "    B -- No --> C[\"Mark Visited\"]",
    "    B -- Yes --> D[\"Return\"]",
    "    C --> E[\"Process Node\"]",
    "    E --> F[\"Iterate Neighbors\"]",
    "    F --> A",
    "```",
    "",
    "## 9. 复杂度对比表",
    "",
    "| 数据结构 | 空间复杂度 | 时间复杂度 (平均) | 稳定性 |",
    "| :--- | :---: | :---: | :---: |",
    "| 邻接矩阵 | $O(V^2)$ | $O(1)$ 查询 | 高 |",
    "| 邻接表 | $O(V+E)$ | $O(Degree)$ 查询 | 变动 |",
    "| 边列表 | $O(E)$ | $O(E)$ 查询 | 低 |"
  ].join('\n')
};
